<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Non-stationary (s, S) Policy Calculator</title>
    <!-- Bootstrap CSS -->
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
    #chartContainer {
    	width: 100%;
    	height: auto;
	}

	#inventoryChart {
    	width: 100%;
    	height: 100%;
	}
    </style>
</head>
<body>
    <div class="container mt-5">
        <h1 class="text-center">Non-stationary (s, S) Policy Calculator</h1>
        <div class="mt-4">
        This online tool tackles the inventory control challenge in a finite-horizon periodic-review system. It incorporates fixed replenishment setup costs and linear costs for holding and backorders. The tool determines the parameters for the optimal (s, S) inventory control policy. For a given set of parameters, it calculates the re-order and order-up-to levels for each period, aiming to minimize the expected total costs over the planning horizon. Additionally, it displays the resulting control policy.
        </div>     
        <div class="mt-4">   
        <div class="form-group">
            <form id="apiForm" style="text-align: center;">
        		<label for="jsonInput">JSON Input</label><br>
        		<textarea id="jsonInput" name="jsonInput" rows="10" cols="50">
{
	"K": 50, 
	"h": 1, 
	"p": 10, 
	"d": [30,40,30,40,30]
}				</textarea><br><br>
        		<button type="button" onclick="sendPostRequest()">Compute</button>
    		</form>
    		<div class="card-body">
    			<h5 class="card-title">Parameters:</h5>
    			<p class="card-text">
    			<strong>K:</strong> the fixed ordering cost<br>
				<strong>h:</strong> the proportional holding cost<br>
    			<strong>p:</strong> the penalty cost<br>
    			<strong>d:</strong> the Poisson demand rate in each period
    			</p>
  			</div>
        </div>
        </div>        
        <div class="mt-4">
            <h5>Reference:</h5>
            <p>Herbert E. Scarf. Optimality of (s, S) policies in the dynamic inventory problem. In K. J. Arrow, S. Karlin, and P. Suppes, editors, Mathematical Methods in the Social Sciences, pages 196â€“202. Stanford University Press, Stanford, CA, 1960.</p>
        </div>
        <div id="responseOutput" class="mt-4"></div>
        <div id="chartContainer" class="mt-4">
        	<canvas id="inventoryChart" height="400"></canvas>
    	</div>
    	<div class="mt-4" style="text-align: center;">
    		<p class="voffset10">
      		<a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
      		<img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png"></a>
      		</p>
      		<p class="voffset10" id="copyright"></p>
      		 <!-- Copyright -->
  			<script>
  			var current_date = new Date();
  			document.getElementById("copyright").innerHTML = 'Copyright &copy;&nbsp;'+current_date.getFullYear()+'<br>Roberto Rossi';
  			</script>
    	</div>
    </div>

    <!-- Bootstrap JS and dependencies -->
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <!-- Existing JavaScript logic -->
    <script>
        let chart;
        let myInterval;

        async function sendPostRequest() {
            const jsonInput = document.getElementById('jsonInput').value;
            jsonInputObj = JSON.parse(jsonInput);
            try {
                const response = await fetch('https://inventory-api-9uz7.onrender.com/ss', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: jsonInput
                });
                if (!response.ok) {
                    throw new Error('Network response was not ok ' + response.statusText);
                }
                const result = await response.json();
                displayResponse(result);
                plotInventory(0, jsonInputObj.d, result.s, result.S);
            } catch (error) {
                console.error('Fetch error: ', error);
                document.getElementById('responseOutput').innerText = 'Error: ' + error.message;
            }
        }
        
        function displayResponse(result) {
            const responseOutput = document.getElementById('responseOutput');
            responseOutput.innerHTML = `
                <h5>Results</h5>
                <p>Optimal Cost: ${result.optCost.toFixed(1)}</p>
                <p>Computation time: ${result.solTime} s</p>
                <h5>S:</h5>
                ${createTable(result.S)}
                <h5>s:</h5>
                ${createTable(result.s)}
            `;
            document.getElementById('chartContainer').style.display = 'block';
        }

        function createTable(list) {
            let table = '<table class="table"><tr>';
            list.forEach(item => {
                table += `<td>${item}</td>`;
            });
            table += '</tr></table>';
            return table;
        }
        
        function poisson(lambda) {
    		let L = Math.exp(-lambda);
    		let k = 0;
    		let p = 1;

   		 do {
  		      k++;
  		      p *= Math.random();
  		  } while (p > L);
	
  		  return k - 1;
		}

        function simulateInventory(initialInventory, means, sLevels, SLevels) {
            const periods = means.length;
            let inventory = initialInventory;
            let inventoryLevels = [{ x: 0, y: inventory }];
            let orders = [];

            for (let t = 0; t < periods; t++) {
                let demand = poisson(means[t]);

                if (inventory < sLevels[t]) {
                    let orderQuantity = SLevels[t] - inventory;
                    orders.push(orderQuantity);
                    inventoryLevels.push({ x: t, y: inventory });
                    inventory += orderQuantity;
                    inventoryLevels.push({ x: t, y: inventory });
                } else {
                    orders.push(0);
                }

                inventory -= demand;
                inventoryLevels.push({ x: t + 1, y: inventory });
            }

            return { inventoryLevels, orders };
        }

        function plotInventory(initialInventory, means, sLevels, SLevels) {
            const ctx = document.getElementById('inventoryChart').getContext('2d');
            
            if (chart) {
                chart.destroy();
            }

            chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Inventory Level',
                            data: [],
                            borderColor: 'blue',
                            backgroundColor: 'blue',
                            showLine: true,
                            fill: false
                        },
                        {
                            label: 's Level',
                            data: sLevels.map((s, i) => ({ x: i, y: s })),
                            borderColor: 'red',
                            backgroundColor: 'red',
                            pointRadius: 5,
                            pointBackgroundColor: 'red',
                            showLine: false
                        },
                        {
                            label: 'S Level',
                            data: SLevels.map((S, i) => ({ x: i, y: S })),
                            borderColor: 'green',
                            backgroundColor: 'green',
                            pointRadius: 5,
                            pointBackgroundColor: 'green',
                            showLine: false
                        }
                    ]
                },
                options: {
                    responsive: true,
       		        maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Periods'
                            },
                            type: 'linear',
                            position: 'bottom'
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Inventory Level'
                            }
                        }
                    }
                }
            });

            function updateChart() {
                const { inventoryLevels } = simulateInventory(initialInventory, means, sLevels, SLevels);
                chart.data.datasets[0].data = inventoryLevels;
                chart.update();
            }

            updateChart();
            if (myInterval) {
  				clearInterval(myInterval);
			} 
            myInterval = setInterval(updateChart, 1000);
        }
    </script>
</body>
</html>
